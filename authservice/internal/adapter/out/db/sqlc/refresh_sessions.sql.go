// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refresh_sessions.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createRefreshSession = `-- name: CreateRefreshSession :exec
INSERT INTO refresh_sessions (
  id,
  account_id,
  refresh_token_hash,
  created_at,
  expires_at,
  revoked_at,
  revoke_reason,
  rotated_from,
  ip,
  user_agent
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type CreateRefreshSessionParams struct {
	ID               uuid.UUID
	AccountID        uuid.UUID
	RefreshTokenHash string
	CreatedAt        time.Time
	ExpiresAt        time.Time
	RevokedAt        sql.NullTime
	RevokeReason     sql.NullString
	RotatedFrom      uuid.NullUUID
	Ip               pqtype.Inet
	UserAgent        sql.NullString
}

func (q *Queries) CreateRefreshSession(ctx context.Context, arg CreateRefreshSessionParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshSession,
		arg.ID,
		arg.AccountID,
		arg.RefreshTokenHash,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.RevokedAt,
		arg.RevokeReason,
		arg.RotatedFrom,
		arg.Ip,
		arg.UserAgent,
	)
	return err
}

const deleteExpiredRefreshSessions = `-- name: DeleteExpiredRefreshSessions :exec
DELETE FROM refresh_sessions
WHERE expires_at <= $1
`

func (q *Queries) DeleteExpiredRefreshSessions(ctx context.Context, expiresAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredRefreshSessions, expiresAt)
	return err
}

const getRefreshSessionByHash = `-- name: GetRefreshSessionByHash :one
SELECT
    id,
    account_id,
    refresh_token_hash,
    created_at,
    expires_at,
    revoked_at,
    revoke_reason,
    rotated_from,
    ip,
    user_agent
FROM refresh_sessions
WHERE refresh_token_hash = $1
`

func (q *Queries) GetRefreshSessionByHash(ctx context.Context, refreshTokenHash string) (RefreshSession, error) {
	row := q.db.QueryRowContext(ctx, getRefreshSessionByHash, refreshTokenHash)
	var i RefreshSession
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.RefreshTokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.RevokeReason,
		&i.RotatedFrom,
		&i.Ip,
		&i.UserAgent,
	)
	return i, err
}

const getRefreshSessionByID = `-- name: GetRefreshSessionByID :one
SELECT
    id,
    account_id,
    refresh_token_hash,
    created_at,
    expires_at,
    revoked_at,
    revoke_reason,
    rotated_from,
    ip,
    user_agent
FROM refresh_sessions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRefreshSessionByID(ctx context.Context, id uuid.UUID) (RefreshSession, error) {
	row := q.db.QueryRowContext(ctx, getRefreshSessionByID, id)
	var i RefreshSession
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.RefreshTokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.RevokeReason,
		&i.RotatedFrom,
		&i.Ip,
		&i.UserAgent,
	)
	return i, err
}

const listAccountActiveRefreshSessions = `-- name: ListAccountActiveRefreshSessions :many
SELECT
    id,
    account_id,
    refresh_token_hash,
    created_at,
    expires_at,
    revoked_at,
    revoke_reason,
    rotated_from,
    ip,
    user_agent
FROM refresh_sessions
WHERE account_id = $1
    AND revoked_at IS NULL
    AND expires_at > $2
ORDER BY created_at DESC
`

type ListAccountActiveRefreshSessionsParams struct {
	AccountID uuid.UUID
	ExpiresAt time.Time
}

func (q *Queries) ListAccountActiveRefreshSessions(ctx context.Context, arg ListAccountActiveRefreshSessionsParams) ([]RefreshSession, error) {
	rows, err := q.db.QueryContext(ctx, listAccountActiveRefreshSessions, arg.AccountID, arg.ExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RefreshSession
	for rows.Next() {
		var i RefreshSession
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.RefreshTokenHash,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.RevokeReason,
			&i.RotatedFrom,
			&i.Ip,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllAccountRefreshSessions = `-- name: RevokeAllAccountRefreshSessions :exec
UPDATE refresh_sessions
SET
    revoked_at = $2,
    revoke_reason = $3
WHERE account_id = $1
    AND revoked_at IS NULL
`

type RevokeAllAccountRefreshSessionsParams struct {
	AccountID    uuid.UUID
	RevokedAt    sql.NullTime
	RevokeReason sql.NullString
}

func (q *Queries) RevokeAllAccountRefreshSessions(ctx context.Context, arg RevokeAllAccountRefreshSessionsParams) error {
	_, err := q.db.ExecContext(ctx, revokeAllAccountRefreshSessions, arg.AccountID, arg.RevokedAt, arg.RevokeReason)
	return err
}

const revokeRefreshSession = `-- name: RevokeRefreshSession :exec
UPDATE refresh_sessions
SET
    revoked_at = $2,
    revoke_reason = $3
WHERE id = $1
`

type RevokeRefreshSessionParams struct {
	ID           uuid.UUID
	RevokedAt    sql.NullTime
	RevokeReason sql.NullString
}

func (q *Queries) RevokeRefreshSession(ctx context.Context, arg RevokeRefreshSessionParams) error {
	_, err := q.db.ExecContext(ctx, revokeRefreshSession, arg.ID, arg.RevokedAt, arg.RevokeReason)
	return err
}

const revokeRefreshSessionDescendants = `-- name: RevokeRefreshSessionDescendants :exec
WITH RECURSIVE chain(target_id) AS (
    SELECT rs_init.id
    FROM refresh_sessions rs_init
    WHERE rs_init.id = $1

    UNION ALL

    SELECT rs_rec.id
    FROM refresh_sessions rs_rec
             JOIN chain c ON rs_rec.rotated_from = c.target_id
)
UPDATE refresh_sessions
SET
    revoked_at = $2,
    revoke_reason = $3
FROM chain
WHERE refresh_sessions.id = chain.target_id
  AND refresh_sessions.revoked_at IS NULL
`

type RevokeRefreshSessionDescendantsParams struct {
	ID           uuid.UUID
	RevokedAt    sql.NullTime
	RevokeReason sql.NullString
}

func (q *Queries) RevokeRefreshSessionDescendants(ctx context.Context, arg RevokeRefreshSessionDescendantsParams) error {
	_, err := q.db.ExecContext(ctx, revokeRefreshSessionDescendants, arg.ID, arg.RevokedAt, arg.RevokeReason)
	return err
}
